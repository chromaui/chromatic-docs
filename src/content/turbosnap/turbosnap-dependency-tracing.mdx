---
layout: "../../layouts/Layout.astro"
title: TurboSnap Dependency Tracing
description: Speed up tests by detecting file changes with Git
sidebar: { order: 4, label: "Dependency Tracing" }
slug: "turbosnap/dependency-tracing"
---

# TurboSnap Dependency Tracing
TurboSnap analyzes both a project's git history and Webpack's dependency graph to identify which stories have been potentially impacted by changes.  But what is Webpack's dependency graph and how does TurboSnap use it to trace dependency changes?  How does this work for projects built with Vite?  This overview will answer these questions and help you better understand dependency tracing for TurboSnap.

## Tracing dependencies with Webpack
To start, let's visit [Webpack's dependency graph concept](https://webpack.js.org/concepts/dependency-graph/):

> ❝ Any time one file depends on another, webpack treats this as a dependency. This allows webpack to take non-code assets, such as images or web fonts, and also provide them as dependencies for your application.
> 
> When webpack processes your application, it starts from a list of modules defined on the command line or in its configuration file. Starting from these [entry points](https://webpack.js.org/concepts/entry-points/), webpack recursively builds a dependency graph that includes every module your application needs, then bundles all of those modules into a small number of bundles - often, only one - to be loaded by the browser. ❞

TurboSnap uses [Webpack's Stats Data API](https://webpack.js.org/api/stats) to generate a JSON file containing statistics about the modules for a project. These statistics are how TurboSnap analyzes a project's dependency graph, as it gives the details about the asset objects, any related chunks (or grouped modules), and the module dependencies that rely on the asset.

This file is generated when a customer adds `--stats-json` (or `--webpack-stats-json` for SB versions < v8). Chromatic has an option called `trim-stats-file` that can be used to make the file more human-readable, since it can be a bit confusing to read through. Here's an example of the command used to run it, but a customer can add a path at the end if they want the stats file to built to a custom directory:

```shell
npx chromatic trim-stats-file
```

### Reading the trimmed stats file
After running the above `trim-stats-file` command, Chromatic will output a `preview-stats.trimmed.json` file. While this file is more human-readable, it can still be a bit more confusing (though much less daunting than the non-trimmed file).

Let's break down an example from the file!

```json
    {
      "id": "./src/inputs/PinInput/PinInput.tsx",
      "name": "./src/inputs/PinInput/PinInput.tsx + 4 modules",
      "modules": [
        { "name": "./src/inputs/PinInput/PinInput.tsx" },
        { "name": "./src/inputs/PinInput/SeparatedPinInput.tsx" },
        { "name": "./src/inputs/PinInput/SinglePinInput.tsx" },
        { "name": "./src/inputs/utils.ts" },
        { "name": "./src/inputs/PinInput/PinCaret.tsx" }
      ],
      "reasons": [
        { "moduleName": "./src/data/DataGrid/cells/EditablePinInput.tsx" },
        { "moduleName": "./src/inputs/PinInput/index.ts" }
      ]
    },
```

In the above example, we have an asset with the `chunkName` of `./src/inputs/PinInput/PinInput.tsx + 4 modules`. There's a total of five modules within this chunk (which we could likely gather from the name):

 1. `./src/inputs/PinInput/PinInput.tsx`
 2. `./src/inputs/PinInput/SeparatedPinInput.tsx`
 3. `./src/inputs/PinInput/SinglePinInput.tsx`
 4. `./src/inputs/utils.ts`
 5. `./src/inputs/PinInput/PinCaret.tsx`

Using the above information, we can identify that we have an asset that is one chunk containing five modules.

Below the information that identifies the chunk, we see another set of modules under `reasons`. These are the modules that are part of the asset's dependency graph. In the above example, we have two modules that are dependent on this asset:

 1. `./src/data/DataGrid/cells/EditablePinInput.tsx`
 2. `./src/inputs/PinInput/index.ts`

Using the modules `reasons`, we can identify that any changes to the asset chunk's modules may have an impact on the dependent modules.

What's the asset object look like when it comes to story files? Usually a bit different:

```json
    {
      "id": "./src/inputs/PinInput/stories/PinInput.stories.tsx",
      "name": "./src/inputs/PinInput/stories/PinInput.stories.tsx + 4 modules",
      "modules": [
        { "name": "./src/inputs/PinInput/stories/PinInput.stories.tsx" },
        { "name": "./src/inputs/PinInput/stories/PinInputWithNoCopyPaste.storyfile.tsx" },
        { "name": "./src/inputs/PinInput/stories/PinInputWithNoCopyPaste.storyfile.tsx?raw" },
        { "name": "./src/inputs/PinInput/stories/PinInputWithValidation.storyfile.tsx" },
        { "name": "./src/inputs/PinInput/stories/PinInputWithValidation.storyfile.tsx?raw" }
      ],
      "reasons": [
        { "moduleName": "./src/ lazy ^\\.\\/.*$ include: (?%21.*node_modules)(?:\\/src(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.(js%7Cjsx%7Cts%7Ctsx))$ chunkName: [request] namespace object" }
      ]
    },
```

Under `reasons`, we see a `moduleName` that looks like a path pattern.  If you were to look at the non-trimmed file, you'd see the `issuerPath`'s are `"./storybook-config-entry.js"` and `"./storybook-stories.js"` because the dependency is the project's Storybook config:

```js
// main.js

/** @type { import('@storybook/react-webpack5').StorybookConfig } */
const config = {
  stories: [{
    directory: '../',
    files: '**/*.@(mdx|stories.@(js|jsx|ts|tsx))',
  }],
  // ...
};
export default config;
```

Using the trimmed stats file, you can [search for a file path](/docs/turbosnap/troubleshooting/#why-are-no-changes-being-detected) to see whether it's part of the dependency graph for another module. 

## Tracing dependencies with Vite
Prior to Storybook v8, Vite was supported via the [`vite-plugin-turbosnap` by IanVS](https://github.com/IanVS/vite-plugin-turbosnap).  Starting in v8, the plugin has been integrated and TurboSnap supports Vite out-of-the-box.  The plugin does this by generating a `preview-stats.json` file after collecting information about each module being built and constructing a mapping between each file and all of the files which import it.  This mimics the file that is created by Webpack, with only the information that Chromatic's CLI needs to perform checks using TurboSnap.
