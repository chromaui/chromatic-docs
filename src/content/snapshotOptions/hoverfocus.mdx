---
layout: "../../layouts/Layout.astro"
title: Hover and focus states
description: Learn how to capture hover and focus states
sidebar: { order: 5, label: Hover and focus }
---

import IntegrationSnippets from "../../components/IntegrationSnippets.astro";



# Hover and focus states

Components can respond differently based on hover or focus events. Here are a few techniques for capturing the result of these user events Chromatic.

## Make your stories interactive

Stories are capable of simulating user interactions via the [`play`](https://storybook.js.org/docs/writing-stories/play-function) function in Storybook 6.4 and above. Interactions allow you to verify how a component responds to user input (e.g., hover, focus, click, type). Chromatic awaits `play` function execution before taking a snapshot.

## JavaScript-triggered hover states

If the hover behavior is triggered via JavaScript like tooltips or dropdowns, write a `play` function to simulate it using Storybook's instrumented version of Testing Library. For example:

```js
// Form.stories.js|jsx

/*
 * Replace the @storybook/test package with the following if you are using a version of Storybook earlier than 8.0:
 * import { userEvent, waitFor, within } from "@storybook/testing-library";
 */
import { userEvent, waitFor, within } from "@storybook/test";

import { Form } from "./LoginForm";

export default {
  component: Form,
  title: "Form",
};

export const WithHoverState = {
  play: async ({ canvasElement }) => {
    // Starts querying the component from its root
    const canvas = within(canvasElement);
    // Looks up the input and fills it.
    const emailInput = canvas.getByLabelText("email", {
      selector: "input",
    });
    await userEvent.type(emailInput, "Example");
    // Looks up the button and interacts with it.
    const submitButton = canvas.getByRole("button");
    await userEvent.click(submitButton);
    // Triggers the hover state
    await waitFor(async () => {
      await userEvent.hover(canvas.getByLabelText("Email error"));
    });
  },
};
```

## CSS :hover state

CSS includes the `:hover` pseudo-class that allow precise styling of an element on cursor hover. This is a "trusted event" for web browsers, meaning it can't be simulated by the `play` function. There are multiple ways you can snapshot this state.

<details>

  <summary>Use CSS class names</summary>

Add a CSS class name that mirrors the states you're trying to test (e.g., `hover`, `active`):

```css
/* Component styles */
MyComponent:hover,
MyComponent.hover {
  background: purple;
}

MyComponent:active,
MyComponent.active {
  background: green;
}
```

Then write a story that utilizes the class name:

```js
// MyComponent.stories.js|jsx

import { MyComponent } from "./MyComponent";

export default {
  component: MyComponent,
  title: "MyComponent",
};

export const HoverStatewithClass = {
  args: {
    ...HoverState.args,
    className: "hover",
  },
};

export const ActiveStatewithClass = {
  args: {
    ...ActiveState.args,
    className: "active",
  },
};
```

You can also extend this technique using a JS wrapper that [automates adding a class](https://github.com/Workday/canvas-kit/pull/377/files).

</details>

<details>

  <summary>Trigger CSS states via props</summary>

Although not recommended, you can test an element's states by creating a separate "pure" stateless component. Then use it to test the exact configurations you are after via props. For example:

```js
// MyComponent.js|jsx

export function MyComponent({ isHovered, isActive, label }) {
  return (
    <Button isHovered={isHovered} isActive={isActive}>
      {label}
    </Button>
  );
}

MyComponent.defaultProps = {
  isHovered: false,
  isActive: false,
  label: "Submit",
};
```

You can write the following story to trigger the props:

```js
// MyComponent.stories.js|jsx

import { MyComponent } from "./MyComponent";

export default {
  component: MyComponent,
  title: "MyComponent",
};

export const HoverState = {
  args: {
    isHovered: true,
    label: `I'm :hover`,
  },
};

export const ActiveState = {
  args: {
    isActive: true,
    label: `I'm :active`,
  },
};
```

</details>

<details>
<summary>With Storybook's Pseudo States addon</summary>

For atomic, functional components with CSS pseudo-classes (e.g., `hover`, `active`), try the [Storybook's Pseudo States addon](https://storybook.js.org/addons/storybook-addon-pseudo-states) to test pseudo states. For example:

```js
// Button.stories.js|jsx

import { Button } from "./Button";

export default {
  component: Button,
  title: "Button",
};

export const WithHoverState = {
  args: {
    size: "small",
    label: "Button",
  },
  parameters: {
    // Toggles the component hover state via parameter.
    pseudo: { hover: true },
  },
};
```

</details>



## Focusing DOM elements

### With Storybook

If you're working with a UI component that provides a visual response to the user focusing on a specific element, whether with CSS or JavaScript, you can simulate this behavior by adjusting your tests to include a [`play`](https://storybook.js.org/docs/writing-stories/play-function) function that mirrors the user's interaction. For example:

```ts title="src/components/Auth.stories.ts|tsx"
// Adjust this import to match your framework (e.g., nextjs, vue3-vite)
import type { Meta, StoryObj } from "@storybook/your-framework";

/*
* Replace the @storybook/test package with the following if you are using a version of Storybook earlier than 8.0:
* import { userEvent, within } from "@storybook/testing-library";
* import { expect } from "@storybook/jest";
*/
import { expect, userEvent, within } from "@storybook/test";

import { LoginForm } from "./LoginForm";

const meta: Meta<typeof LoginForm> = {
  component: LoginForm,
  title: "LoginForm",
};

export default meta;
type Story = StoryObj<typeof LoginForm>;

export const Default: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    await userEvent.type(canvas.getByLabelText("email"), "test@email.com");
    await userEvent.type(canvas.getByLabelText("password"), "KC@2N6^?vsV+)w1t");

    const SubmitButton = canvas.getByRole("button", { name: "Login" });
    await SubmitButton.focus();
    await expect(SubmitButton).toHaveFocus();
  },
};
```

### With Playwright or Cypress

If you're running tests with Playwright or Cypress, you can simulate JavaScript-based focus events using Playwright's `focus` [locator](https://playwright.dev/docs/next/api/class-locator#locator-focus) or Cypress's [`focus`](https://docs.cypress.io/api/commands/focus) command to verify how the UI responds when a specific element receives focus. For example:

{/* prettier-ignore-start */}

<IntegrationSnippets>
  <Fragment slot="playwright" visible="true">
    ```ts title="tests/Auth.spec.js|ts"
    import { test, expect } from "@chromatic-com/playwright";

    test.describe("Authentication", () => {
      test("Verifies the authentication works with keyboard navigation", async ({ page }) => {
        await page.goto("/auth");

        await page.locator('input[name="email"]').fill("test@email.com");
        await page.locator('input[name="password"]').fill("KC@2N6^?vsV+)w1t");

        await page.getByRole("button", {name: "Login"}).focus();
        await expect(page.getByRole("button")).toBeFocused();
      });
    });
    ```
  </Fragment>
  <Fragment slot="cypress" visible="true">
    ```ts title="cypress/e2e/Auth.cy.js|ts"
    describe("Authentication", () => {
      it("Verifies the authentication works with keyboard navigation", () => {
        cy.visit("/auth");

        cy.get('input[name="email"]').type("test@email.com");
        cy.get('input[name="password"]').type("KC@2N6^?vsV+)w1t");

        cy.get('button[type="submit"]').focus();
        cy.get('button[type="submit"]').should('have.focus');
      });
    });
    ```
  </Fragment>
</IntegrationSnippets>

{/* prettier-ignore-end */}

---

## Frequently asked questions

<details>
<summary>Why are focus states visible in Storybook but not captured in a snapshot?</summary>

By default, when Chromatic snapshots a Storybook story, it will trim the snapshot to the dimensions of the root node of the story. However, this behavior can lead to some inconsistencies, such as excluding outlined elements and other focus styles from the snapshot. 

To solve it, you can adjust your story and provide a [decorator](https://storybook.js.org/docs/writing-stories/decorators#component-decorators) introducing some padding to the story enabling it to be snapshotted correctly.

```ts title="src/components/Login.stories.ts|tsx"
// Adjust this import to match your framework (e.g., nextjs, vue3-vite)
import type { Meta, StoryObj } from "@storybook/your-framework";

import { LoginForm } from "./LoginForm";

const meta: Meta<typeof LoginForm> = {
  component: LoginForm,
  title: "LoginForm",
  decorators: [
    (Story) => (
      <div style={{ padding: "1em" }}>
        <Story />
      </div>
    ),
  ],
};

export default meta;
```
</details>



