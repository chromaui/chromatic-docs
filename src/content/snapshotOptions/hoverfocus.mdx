---
layout: "../../layouts/Layout.astro"
title: Hover and focus states
description: Learn how to capture hover and focus states
sidebar: { order: 5, label: Hover and focus }
---

import IntegrationSnippets from "../../components/IntegrationSnippets.astro";



# Hover and focus states

Components can respond differently based on hover or focus events. Here are a few techniques for capturing the result of these user events Chromatic.

## Make your stories interactive

Stories are capable of simulating user interactions via the [`play`](https://storybook.js.org/docs/writing-stories/play-function) function in Storybook 6.4 and above. Interactions allow you to verify how a component responds to user input (e.g., hover, focus, click, type). Chromatic awaits `play` function execution before taking a snapshot.

## JavaScript-triggered hover states

If the hover behavior is triggered via JavaScript like tooltips or dropdowns, write a `play` function to simulate it using Storybook's instrumented version of Testing Library. For example:

```js
// Form.stories.js|jsx

/*
 * Replace the @storybook/test package with the following if you are using a version of Storybook earlier than 8.0:
 * import { userEvent, waitFor, within } from "@storybook/testing-library";
 */
import { userEvent, waitFor, within } from "@storybook/test";

import { Form } from "./LoginForm";

export default {
  component: Form,
  title: "Form",
};

export const WithHoverState = {
  play: async ({ canvasElement }) => {
    // Starts querying the component from its root
    const canvas = within(canvasElement);
    // Looks up the input and fills it.
    const emailInput = canvas.getByLabelText("email", {
      selector: "input",
    });
    await userEvent.type(emailInput, "Example");
    // Looks up the button and interacts with it.
    const submitButton = canvas.getByRole("button");
    await userEvent.click(submitButton);
    // Triggers the hover state
    await waitFor(async () => {
      await userEvent.hover(canvas.getByLabelText("Email error"));
    });
  },
};
```

## CSS :hover state

CSS includes the `:hover` pseudo-class that allow precise styling of an element on cursor hover. This is a "trusted event" for web browsers, meaning it can't be simulated by the `play` function. There are multiple ways you can snapshot this state.

<details>

  <summary>Use CSS class names</summary>

Add a CSS class name that mirrors the states you're trying to test (e.g., `hover`, `active`):

```css
/* Component styles */
MyComponent:hover,
MyComponent.hover {
  background: purple;
}

MyComponent:active,
MyComponent.active {
  background: green;
}
```

Then write a story that utilizes the class name:

```js
// MyComponent.stories.js|jsx

import { MyComponent } from "./MyComponent";

export default {
  component: MyComponent,
  title: "MyComponent",
};

export const HoverStatewithClass = {
  args: {
    ...HoverState.args,
    className: "hover",
  },
};

export const ActiveStatewithClass = {
  args: {
    ...ActiveState.args,
    className: "active",
  },
};
```

You can also extend this technique using a JS wrapper that [automates adding a class](https://github.com/Workday/canvas-kit/pull/377/files).

</details>

<details>

  <summary>Trigger CSS states via props</summary>

Although not recommended, you can test an element's states by creating a separate "pure" stateless component. Then use it to test the exact configurations you are after via props. For example:

```js
// MyComponent.js|jsx

export function MyComponent({ isHovered, isActive, label }) {
  return (
    <Button isHovered={isHovered} isActive={isActive}>
      {label}
    </Button>
  );
}

MyComponent.defaultProps = {
  isHovered: false,
  isActive: false,
  label: "Submit",
};
```

You can write the following story to trigger the props:

```js
// MyComponent.stories.js|jsx

import { MyComponent } from "./MyComponent";

export default {
  component: MyComponent,
  title: "MyComponent",
};

export const HoverState = {
  args: {
    isHovered: true,
    label: `I'm :hover`,
  },
};

export const ActiveState = {
  args: {
    isActive: true,
    label: `I'm :active`,
  },
};
```

</details>

<details>
<summary>With Storybook's Pseudo States addon</summary>

For atomic, functional components with CSS pseudo-classes (e.g., `hover`, `active`), try the [Storybook's Pseudo States addon](https://storybook.js.org/addons/storybook-addon-pseudo-states) to test pseudo states. For example:

```js
// Button.stories.js|jsx

import { Button } from "./Button";

export default {
  component: Button,
  title: "Button",
};

export const WithHoverState = {
  args: {
    size: "small",
    label: "Button",
  },
  parameters: {
    // Toggles the component hover state via parameter.
    pseudo: { hover: true },
  },
};
```

</details>



## Focusing DOM elements

Enabling focus states in your UI components is essential for ensuring usability, specifically for users navigating with a keyboard or other assistive technologies to interact with the UI seamlessly. Chromatic enables  

Chromatic enables you to test how your UI components respond when a specific element receives focus, ensuring that they meet the required accessibility standards.

When testing UIs, verifying how they respond when a specific element receives focus is essential. This is especially important for ensuring your UI is accessible and meets the required standards.

enables you to test how your UI components respond when a specific element receives focus, ensuring that they meet the required accessibility standards.

When testing UIs, verifying how they respond when a specific element receives focus is essential. This is especially important for ensuring your UI is accessible and meets the required standards. 


{/* 
To test how your UI components respond when a specific element receives focus, you can use Chromatic to capture the focused element in the snapshot, ensuring that your UI meets the required accessibility standards.

When testing UIs, verifying how they respond when a specific element receives focus is essential. This is especially important for ensuring your UI is accessible and meets the required standards.


By focusing on specific elements, you can test how your UI components respond to the focus state, ensuring that they are accessible and usable for all users. Chromatic enables pinpointing focus states in your UI components, allowing you to test how they respond to focus events and ensuring that they meet the required accessibility standards.

. By enabling them in your UI, you're allowing users, specifically those navigating with a keyboard or other assistive technologies, to interact with the UI seamlessly and efficiently. 

When testing UIs, verifying how they respond when a specific element receives focus is essential. This is especially important for ensuring your UI is accessible and meets the required standards. By focusing on specific elements, you can test how your UI components respond to the focus state, ensuring that they are accessible and usable for all users. Chromatic enables pinpointing focus states in your UI components, allowing you to test how they respond to focus events and ensuring that they meet the required accessibility standards. */}

### With Storybook

If you're working with a UI element that provides a visual response to the user focusing on a specific element, whether with CSS or JavaScript, you can emulate this behavior by adjusting your tests to include a [`play`](https://storybook.js.org/docs/writing-stories/play-function) function that mirrors the user's interaction. For example:

```ts title="src/components/Auth.stories.ts|tsx"
// Adjust this import to match your framework (e.g., nextjs, vue3-vite)
import type { Meta, StoryObj } from "@storybook/your-framework";

/*
* Replace the @storybook/test package with the following if you are using a version of Storybook earlier than 8.0:
* import { userEvent, within } from "@storybook/testing-library";
* import { expect } from "@storybook/jest";
*/
import { expect, userEvent, within } from "@storybook/test";

import { LoginForm } from "./LoginForm";

const meta: Meta<typeof LoginForm> = {
  component: LoginForm,
  title: "LoginForm",
};

export default meta;
type Story = StoryObj<typeof LoginForm>;

export const Default: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    await userEvent.type(canvas.getByLabelText("email"), "test@email.com");
    await userEvent.type(canvas.getByLabelText("password"), "KC@2N6^?vsV+)w1t");

    const SubmitButton = canvas.getByRole("button", { name: "Login" });
    await SubmitButton.focus();
    await expect(SubmitButton).toHaveFocus();
  },
};
```
{/* , you can emulate this behavior by adjusting your story to include a `play` function that mirrors the user's interaction with the component. This function should focus on the element you want to test.


If you're running tests with Storybook, you can emulate the user focusing on a specific element by adjusting your tests to include a [`play`]() function that mirrors the user's interaction with the component wh

you can emulate the user focusing on a specific element by adjusting your story's to include an interaction test that */}


### With Playwright or Cypress

To emulate the user focusing on a specific element in your Playwright or Cypress tests, you can use the built-in methods and verify how the UI responds when a specific element receives focus (e.g., buttons, inputs). When Chromatic runs your tests, it snapshots the focused element, enabling you to test JavaScript-based interactions that trigger focus events in your UI elements.

{/* 
This allows you to test JavaScript-based interactions that trigger focus events. When Chromatic runs your tests, it will capture the focused element in the snapshot.


To emulate the user focusing on a specific element in your Playwright or Cypress tests, you can use the built-in `focus` methods and verify how the UI responds when a specific element receives focus (e.g., buttons, input fields). This allows you to test JavaScript-based interactions that trigger focus events. When Chromatic runs your tests, it will capture the focused element in the snapshot.



To emulate the user focusing on a specific element in your Playwright or Cypress tests, you can use the built-in `focus` methods and verify how the UI responds when a specific element receives focus (e.g., buttons, input fields). This allows you to test JavaScript interactions that trigger focus events. When Chromatic runs your tests, it will capture the focused element in the snapshot. */}

{/* to interact with UI elements and test JavaScript based interactions that trigger focus events.


 simulating how the UI responds when focused. 

 UI. When Chromatic runs your tests, it will 

, enabling you to test JavaScript interactions that trigger focus events. 

This method triggers the focus event on the element, allowing you to test how your component responds to the focus state.


Caveat about css */}


{/* To emulate the user focusing on a specific element in your Playwright or Cypress tests, you can you use the built-in `focus` methods and verify how the UI responds when a specific element recieves focus (e.g., buttons, input fields). When Chromatic runs your tests it will capture the focused element in the snapshot, enabling you to test J


To emulate the user focusing on a specific element in your Playwright or Cypress tests, you can you use the built-in `focus` methods and verify how the UI responds when a specific element recieves focus (e.g., buttons, input fields), alowing you to test JavaScript interactions that trigger focus events. When Chromatic runs your tests it will capture the focused element in the snapshot.

and verify how the UI responds when a specific element recieves focus (e.g., buttons, input fields). When Chromatic runs your tests it will capture the focused element in the snapshot, enabling you to test J

To emulate the user focusing on a specific element in your Playwright or Cypress tests, you can use the Playwright's `focus` locator or Cypress's `focus` commands to verify how the UI behaves when the element is focused. When Chromatic runs your tests, it will capture the focused element in the snapshot, enabling you to test JavaScript interactions that trigger focus events.

To emulate the user focusing on a specific element in your Playwright or Cypress tests, you can use the Playwright's [`focus`]() locator or Cypress's [`focus` command]() to test JavaScript interactions that trigger focus events in your UI elements. When Chromatic runs your tests, it will capture the focused element in the snapshot, enabling you to test JavaScript interactions that trigger focus events. */}


{/* prettier-ignore-start */}

<IntegrationSnippets>
  <Fragment slot="playwright" visible="true">
    ```ts title="tests/Auth.spec.js|ts"
    import { test, expect } from "@chromatic-com/playwright";

    test.describe("Authentication", () => {
      test("Verifies the authentication works with keyboard navigation", async ({ page }) => {
        await page.goto("/auth");

        await page.locator('input[name="email"]').fill("test@email.com");
        await page.locator('input[name="password"]').fill("KC@2N6^?vsV+)w1t");

        await page.getByRole("button", {name: "Login"}).focus();
        await expect(page.getByRole("button")).toBeFocused();
      });
    });
    ```
  </Fragment>
  <Fragment slot="cypress" visible="true">
    ```ts title="cypress/e2e/Auth.cy.js|ts"
    describe("Authentication", () => {
      it("Verifies the authentication works with keyboard navigation", () => {
        cy.visit("/auth");

        cy.get('input[name="email"]').type("test@email.com");
        cy.get('input[name="password"]').type("KC@2N6^?vsV+)w1t");

        cy.get('button[type="submit"]').focus();
        cy.get('button[type="submit"]').should('have.focus');
      });
    });
    ```
  </Fragment>
</IntegrationSnippets>

{/* prettier-ignore-end */}

---

## Frequently asked questions

<details>
<summary>Why are focused states visible in Storybook but not captured in a snapshot?</summary>

By default, when Chromatic snapshots a Storybook story, it will trim the snapshot to the dimensions of the root node of the story. However, this behavior can lead to some inconsistencies, such as excluding outlined elements and other focus styles from the snapshot. 

To solve it, you can adjust your story and provide a [decorator](https://storybook.js.org/docs/writing-stories/decorators#component-decorators) introducing some padding to the story enabling it to be snapshotted correctly.

```ts title="src/components/Login.stories.ts|tsx"
// Adjust this import to match your framework (e.g., nextjs, vue3-vite)
import type { Meta, StoryObj } from "@storybook/your-framework";

import { LoginForm } from "./LoginForm";

const meta: Meta<typeof LoginForm> = {
  component: LoginForm,
  title: "LoginForm",
  decorators: [
    (Story) => (
      <div style={{ padding: "1em" }}>
        <Story />
      </div>
    ),
  ],
};

export default meta;
```
</details>