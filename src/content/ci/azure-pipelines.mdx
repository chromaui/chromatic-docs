---
layout: "../../layouts/Layout.astro"
title: Automate Chromatic with Azure
description: Learn how to configure Chromatic with Azure
sidebar: { order: 7, label: Azure Pipelines }
---

import IntegrationSnippets from "../../components/IntegrationSnippets.astro";

# Automate Chromatic with Azure Pipelines

Chromaticâ€™s automation can be included as part of your [multistage Azure Pipelines](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages?view=azure-devops&tabs=yaml) workflow with relative ease.

## Setup

To integrate Chromatic with your existing pipeline, you'll need to add the following:

{/* prettier-ignore-start */}
<IntegrationSnippets>
  <Fragment slot="storybook">
    ```yml title="azure-pipelines.yml"
    trigger:
      - main

    pool:
      vmImage: 'ubuntu-latest'

    stages:
      - stage: UI_Tests
        displayName: "UI Tests"
        jobs:
          - job: Chromatic
            variables:
              npm_config_cache: $(Pipeline.Workspace)/.npm
            steps:
              - checkout: self
                displayName: "Get Full Git History"
                fetchDepth: 0
              - task: NodeTool@0
                displayName: "Install Node.js"
                inputs:
                  versionSpec: "20.12.2"
              - task: Cache@2
                displayName: "Install and cache dependencies"
                inputs:
                  key: 'npm | "$(Agent.OS)" | package-lock.json'
                  restoreKeys: |
                    npm | "$(Agent.OS)"
                  path: $(npm_config_cache)
              - script: npm ci
                condition: ne(variables.CACHE_RESTORED, 'true')
              - task: CmdLine@2
                displayName: "Run Chromatic"
                inputs:
                  script: npx chromatic
                env:
                  CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
    ```
  </Fragment>
  <Fragment slot="playwright">
    ```yml title="azure-pipelines.yml"
    trigger:
      - main

    pool:
      vmImage: 'ubuntu-latest'

    stages:
      - stage: UI_Tests
        displayName: "UI Tests"
        jobs:
          - job: Playwright
            displayName: "Run Playwright"
            container: mcr.microsoft.com/playwright:v1.48.1-jammy
            steps:
              - checkout: self
                displayName: "Get Full Git History"
                fetchDepth: 0
              - task: NodeTool@0
                displayName: "Install Node.js"
                inputs:
                  versionSpec: "20.12.2"
              - task: Cache@2
                displayName: "Install and cache dependencies"
                inputs:
                  key: 'npm | "$(Agent.OS)" | package-lock.json'
                  restoreKeys: |
                    npm | "$(Agent.OS)"
                  path: $(npm_config_cache)
              - script: npm ci
                condition: ne(variables.CACHE_RESTORED, 'true')
              - task: CmdLine@2
                displayName: "Run Playwright tests"
                inputs:
                  script: npx playwright test
                env:
                  CI: "true"
              - task: PublishPipelineArtifact@1
                inputs:
                  # Chromatic automatically defaults to the test-results directory.
                  # Replace with the path to your custom directory and adjust the CHROMATIC_ARCHIVE_LOCATION environment variable accordingly.
                  targetPath: test-results
                  artifact: test-results
                  publishLocation: "pipeline"
                condition: succeededOrFailed()
          - job: Chromatic
            dependsOn: Playwright
            displayName: "Run Chromatic"
            variables:
              npm_config_cache: $(Pipeline.Workspace)/.npm
            steps:
              - checkout: self
                displayName: "Get Full Git History"
                fetchDepth: 0
              - task: NodeTool@0
                displayName: "Install Node.js"
                inputs:
                  versionSpec: "20.12.2"
              - task: Cache@2
                displayName: "Install and cache dependencies"
                inputs:
                  key: 'npm | "$(Agent.OS)" | package-lock.json'
                  restoreKeys: |
                    npm | "$(Agent.OS)"
                  path: $(npm_config_cache)
              - script: npm ci
                condition: ne(variables.CACHE_RESTORED, 'true')
              - task: DownloadPipelineArtifact@2
                inputs:
                  buildType: "current"
                  artifactName: "test-results"
                  targetPath: "$(System.DefaultWorkingDirectory)/test-results"
              - task: CmdLine@2
                displayName: "Run Chromatic"
                inputs:
                  script: npx chromatic --playwright
                env:
                  CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
                  CHROMATIC_ARCHIVE_LOCATION: "test-results"
    ```
  </Fragment>
  <Fragment slot="cypress">
    ```yml title="azure-pipelines.yml"
    trigger:
      - main

    pool:
      vmImage: 'ubuntu-latest'

    stages:
      - stage: UI_Tests
        displayName: "UI Tests"
        jobs:
          - job: Cypress
            displayName: "Run Cypress"
            container: cypress/browsers:node-20.18.0-chrome-130.0.6723.69-1-ff-131.0.3-edge-130.0.2849.52-1
            variables:
              npm_config_cache: $(Pipeline.Workspace)/.npm
            steps:
              - checkout: self
                displayName: "Get Full Git History"
                fetchDepth: 0
              - task: NodeTool@0
                displayName: "Install Node.js"
                inputs:
                  versionSpec: "20.12.2"
              - task: Cache@2
                displayName: "Install and cache dependencies"
                inputs:
                  key: 'npm | "$(Agent.OS)" | package-lock.json'
                  restoreKeys: |
                    npm | "$(Agent.OS)"
                  path: $(npm_config_cache)
              - script: npm ci
                condition: ne(variables.CACHE_RESTORED, 'true')
              - task: CmdLine@2
                displayName: "Run Cypress tests"
                inputs:
                  script: |
                    npm run dev &
                    npx cypress run
                env:
                  ELECTRON_EXTRA_LAUNCH_ARGS: --remote-debugging-port=9222
              - task: PublishPipelineArtifact@1
                inputs:
                  # Chromatic automatically defaults to the cypress/downloads directory.
                  # Replace with the path to your custom directory and adjust the CHROMATIC_ARCHIVE_LOCATION environment variable accordingly.
                  targetPath: cypress/downloads
                  artifact: test-results
                  publishLocation: "pipeline"
                condition: succeededOrFailed()
          - job: Chromatic
            dependsOn: Cypress
            displayName: "Run Chromatic"
            variables:
              npm_config_cache: $(Pipeline.Workspace)/.npm
            steps:
              - checkout: self
                displayName: "Get Full Git History"
                fetchDepth: 0
              - task: NodeTool@0
                displayName: "Install Node.js"
                inputs:
                  versionSpec: "20.12.2"
              - task: Cache@2
                displayName: "Install and cache dependencies"
                inputs:
                  key: 'npm | "$(Agent.OS)" | package-lock.json'
                  restoreKeys: |
                    npm | "$(Agent.OS)"
                  path: $(npm_config_cache)
              - script: npm ci
                condition: ne(variables.CACHE_RESTORED, 'true')
              - task: DownloadPipelineArtifact@2
                inputs:
                  buildType: "current"
                  artifactName: "test-results"
                  targetPath: "$(System.DefaultWorkingDirectory)/cypress/downloads"
              - task: CmdLine@2
                displayName: "Run Chromatic"
                inputs:
                  script: npx chromatic --cypress
                env:
                  CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
                  CHROMATIC_ARCHIVE_LOCATION: "cypress/downloads"
    ```
  </Fragment>
</IntegrationSnippets>

{/* prettier-ignore-end */}

<div class="aside">

We recommend saving the project token as a secret environment variable named `CHROMATIC_PROJECT_TOKEN` for security reasons. In your Azure pipeline configuration, forward it using the `env` option. When the Chromatic CLI is executed, it will read the environment variable automatically without any additional flags. Refer to the official Azure [environment variables documentation](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/set-secret-variables?view=azure-devops&tabs=yaml%2Cbash) to learn more about it.

</div>

### Run Chromatic on specific branches

If you need to customize your workflow to run Chromatic on specific branches, adjust your pipeline like so:

```yml title="azure-pipelines.yml"
# ðŸ‘‡ Event to trigger pipeline execution
trigger:
  branches:
    include:
      - main # ðŸ‘ˆ Filters the execution to run only on the main branch
    exclude:
      - example

# ðŸ‘‡ Configures pipeline execution on pull requests
pr:
  branches:
    include:
      - main # ðŸ‘ˆ Filters the execution to run only on the pull requests for the main branch
    exclude:
      - example
# Additional pipeline configurations
```

<div class="aside">

Read the official Azure [conditional pipeline documentation](https://docs.microsoft.com/en-us/azure/devops/pipelines/build/triggers?view=azure-devops).

</div>

Now your pipeline will only run Chromatic in the `main` branch.

### Run Chromatic on large projects

Chromatic is prepared to handle large file uploads (with a limit of 5000 files, including stories and assets). If your project exceeds this limit, we recommend adjusting your pipeline and run the `chromatic` command with the `--zip` flag to compress your build before uploading it. For example:

```yml title="azure-pipelines.yml"
# Other configurations

# Pipeline stages
stages:
  - stage: UI_Tests
    displayName: "UI Tests"
    # Job list
    jobs:
      - job: Chromatic
        displayName: "Run Chromatic"
        steps:
          # Other steps in the pipeline

          # ðŸ‘‡ Adds Chromatic as a step in the pipeline
          - task: CmdLine@2
            displayName: "Run Chromatic"
            inputs:
              # ðŸ‘‡ Runs Chromatic with the flag to compress the build output.
              script: npx chromatic --zip
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
```

### Run Chromatic on monorepos

Chromatic can be run on monorepos that have multiple subprojects. Each subproject will need its own project token set as an environment variable.

#### Prerequisites

1. Ensure that you're in the correct working directory for the subproject.
2. Have `build-storybook` npm script in the subproject's `package.json` file OR explicitly name the script using the `buildScriptName` parameter and make sure the script is listed in the subproject's `package.json` file.

If you've already built your Storybook in a separate CI step, you can alternatively point the action at the build output using the `storybookBuildDir` parameter.

```yml title="azure-pipelines.yml"
# Other configurations

# Pipeline stages
stages:
  - stage: UI_Tests
    displayName: "UI Tests"

    # ðŸ‘‡ Adds Chromatic as a step in the pipeline
    jobs:
      # ðŸ‘‡ Runs Chromatic sequentially for each monorepo subproject.
      - job: Chromatic_Deploy_1
        displayName: "Publish Project 1 to Chromatic"
        steps:
          # Other steps in the pipeline
          - task: CmdLine@2
            displayName: "Publish Project 1 to Chromatic"
            inputs:
              script: cd packages/project_1 && npx chromatic
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN_1)
      - job: Chromatic_Deploy_2
        displayName: "Publish Project 2 to Chromatic"
        steps:
          # Other steps in the pipeline
          - task: CmdLine@2
            displayName: "Publish Project 2 to Chromatic"
            inputs:
              script: cd packages/project_2 && npx chromatic
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN_2)
```

<div class="aside">

Additional paralellization can be achieved when configuring your workflow to run Chromatic on multiple subprojects. Read the official Azure DevOps [documentation](https://learn.microsoft.com/en-us/azure/devops/pipelines/licensing/concurrent-jobs?view=azure-devops&tabs=ms-hosted).

</div>

### Enable TurboSnap

TurboSnap is an advanced Chromatic feature implemented to improve the build time for large projects, disabled by default once you add Chromatic to your CI environment. To enable it, you'll need to adjust your existing workflow and run the `chromatic` command with the `--only-changed` flag as follows:

```yml title="azure-pipelines.yml"
# Other configurations

# Pipeline stages
stages:
  - stage: UI_Tests
    displayName: "UI Tests"
    # Job list
    jobs:
      - job: Chromatic_Deploy
        displayName: "Run Chromatic"
        steps:
          # Other steps in the pipeline

          # ðŸ‘‡ Adds Chromatic as a step in the pipeline
          - task: CmdLine@2
            displayName: "Run Chromatic"
            inputs:
              # ðŸ‘‡ Enables Chromatic's TurboSnap feature.
              script: npx chromatic --only-changed
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
```

<div class="aside">

TurboSnap is highly customizable and can be configured to fit your requirements. For more information, read our [documentation](/docs/turbosnap).

</div>

### Overriding Chromatic's branch detection

If your Azure pipeline includes a set of rules for branches (e.g., renames the branch, creates ephemeral, or temporary branches) it can lead to unforeseen build errors.

In this case, you can adjust your workflow and include the `--branch-name` flag. This flag overrides Chromatic's default branch detection in favor of the specified branch:

```yml title="azure-pipelines.yml"
# Other configurations

# Pipeline stages
stages:
  - stage: UI_Tests
    displayName: "UI Tests"
    # Job list
    jobs:
      - job: Chromatic
        displayName: Run Chromatic
        steps:
          # Other steps in the pipeline

          # ðŸ‘‡ Adds Chromatic as a step in the pipeline
          - task: CmdLine@2
            displayName: Run Chromatic
            inputs:
              # ðŸ‘‡ Runs Chromatic with the --branch-name flag to override the baseline branch
              script: npx chromatic --branch-name=${YOUR_BRANCH}
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
```

Chromatic will now detect the correct branch and run your workflow. You can also apply this when fixing cross-fork UI comparisons.

### UI Test and UI Review

[UI Tests](/docs/test) and [UI Review](/docs/review) rely on [branch and baseline](/docs/branching-and-baselines) detection to keep track of [snapshots](/docs/snapshots). We recommend the following configuration.

#### Command exit code for "required" checks

If you are using pull request statuses as required checks before merging, you may not want your pipeline to fail if test snapshots render without errors (but with changes). To achieve this, pass the flag `--exit-zero-on-changes` to the `chromatic` command, and your step will continue in such cases. For example:

```yml title="azure-pipelines.yml"
# Other configurations

# Pipeline stages
stages:
  - stage: UI_Tests
    displayName: "UI Tests"
    # Job list
    jobs:
      - job: Chromatic
        displayName: "Run Chromatic"
        steps:
          # Other steps in the pipeline

          # ðŸ‘‡ Adds Chromatic as a step in the pipeline
          - task: CmdLine@2
            displayName: "Run Chromatic"
            inputs:
              #ðŸ‘‡Runs Chromatic with the flag to prevent pipeline failure
              script: npx chromatic --exit-zero-on-changes
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
```

<div class="aside">

Read our [configuration reference documentation](/docs/configure/#options).

</div>

When using `--exit-zero-on-changes` your pipeline execution still stop and fail if your Storybook contains stories that error. If you'd prefer Chromatic _never_ to block your pipeline, you can use `npx chromatic || true`.

#### Re-run failed builds after verifying UI test results

Builds that contain visual changes need to be [verified](/docs/test#verify-ui-changes). They will fail if you are not using `--exit-zero-on-changes`. Once you accept all the changes, re-run the pipeline and the `Run Chromatic` step will pass.

If you deny any change, you will need to make the necessary code changes to fix the test (and thus start a new build) to get Chromatic to pass again.

#### Maintain a clean "main" branch

A clean `main` branch is a development **best practice** and **highly recommended** for Chromatic. This means testing your `main` branch to ensure builds are passing. It's important to note that baselines will not persist through branching and merging unless you test your `main` branch.

If the builds are a result of direct commits to `main`, you will need to accept changes to keep the main branch clean. If they're merged from `feature-branches`, you will need to make sure those branches are passing _before_ you merge into `main`.

#### Azure squash/rebase merge and the "main" branch

Azure's squash/rebase merge functionality creates new commits that have no association to the branch being merged. If you are already using this option, then we will automatically detect this situation and bring baselines over (see [Branching and Baselines](/docs/branching-and-baselines#how-do-baselines-get-preserved-during-squash-and-rebase-merging) for more details).

If youâ€™re using this functionality but notice the incoming changes were not accepted as baselines in Chromatic, then you'll need to adjust the pipeline and include the `--auto-accept-changes` flag. For example:

```yml title="azure-pipelines.yml"
# Other configurations

# Pipeline stages
stages:
  - stage: UI_Tests
    displayName: "UI Tests"
    # Job list
    jobs:
      - job: Chromatic
        displayName: "Run Chromatic"
        steps:
          # Other steps in the pipeline

          # ðŸ‘‡ Checks if the branch is main and runs Chromatic with the flag to accept all changes.
          - task: CmdLine@2
            displayName: "Run Chromatic and auto accept changes"
            condition: and(succeeded(), eq(variables['build.sourceBranch'], 'refs/heads/main'))
            inputs:
              script: npx chromatic --auto-accept-changes
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
            # ðŸ‘‡ Checks if the branch is not main and runs Chromatic
          - task: CmdLine@2
            displayName: "Run Chromatic"
            condition: eq(variables['Build.Reason'], 'PullRequest')
            inputs:
              script: npx chromatic
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
```

<div class="aside">

Read our [configuration reference documentation](/docs/configure/#options).

</div>

Including the `--auto-accept-changes` flag ensures all incoming changes will be accepted as baselines. Additionally, you'll maintain a clean `main` branch.

If you want to test the changes introduced by the rebased branch, you can adjust your workflow and include a new step with the `ignore-last-build-on-branch` flag. For example:

```yml title="azure-pipelines.yml"
# Other configurations

# Pipeline stages
stages:
  - stage: UI_Tests
    displayName: "UI Tests"
    # Job list
    jobs:
      - job: Chromatic
        displayName: "Run Chromatic"
        steps:
          # Other steps in the pipeline

          # ðŸ‘‡ Option to skip the last build on target branch
          - task: CmdLine@2
            displayName: "Run Chromatic"
            inputs:
              script: npx chromatic --ignore-last-build-on-branch=my-branch
            env:
              CHROMATIC_PROJECT_TOKEN: $(CHROMATIC_PROJECT_TOKEN)
```

<div class="aside">

Read our [configuration reference documentation](/docs/configure/#options).

</div>

Including the `--ignore-last-build-on-branch` flag ensures the latest build for the specific branch is not used as a baseline.

#### Run Chromatic on external forks of open source projects

You can enable PR checks for external forks by sharing your project token where you configured the Chromatic command (often in `package.json` or in the pipeline step).

Sharing project tokens allows contributors and others to run Chromatic builds on your project, consuming your snapshot quota. They cannot access your account, settings, or accept baselines. This can be an acceptable tradeoff for open source projects that value community contributions.

#### Skipping builds for certain branches

Sometimes you might want to skip running a build for a certain branch, but still have Chromatic mark the latest commit on that branch as "passed". Otherwise pull requests could be blocked due to required checks that remain pending. To avoid this issue, you can run `chromatic` with the `--skip` flag. This flag accepts a branch name or glob pattern.

One use case for this feature is skipping builds for branches created by a bot. For instance, Renovate automatically updates a projects dependencies. Although some dependencies can result in UI changes, you might not find it worthwhile to run Chromatic for every single dependency update. Instead, you could rely on Chromatic running against the `main` or `develop` branch.

To skip builds for `renovate` branches, use the following:

```shell
npx chromatic --skip 'renovate/**'
```

<div class="aside">

Read our [configuration reference documentation](/docs/configure/#options).

</div>

To apply this to multiple branches, use an "extended glob". See the [globs guide] for details.

```shell
npx chromatic --skip '@(renovate/**|your-custom-branch/**)'
```

[globs guide]: /docs/globs

### Automate pull request status checks with Azure functions

If you need to integrate Chromatic with Azure to enable pull request status checks based on the status of the Chromatic build, you can use [Azure functions](https://learn.microsoft.com/en-us/azure/azure-functions/functions-get-started?pivots=programming-language-javascript) to create a Webhook that listens for Chromatic build status events. You will need an active Azure account and a function application that is already configured to allow this integration.

Run the following command to install the required dependencies:

```bash
npm install azure-devops-node-api
```

Update your function to include the following:

{/* prettier-ignore-start */}

```js title="src/functions/chromatic-status-check.js"
const azureDevOps = require("azure-devops-node-api");

const { GitStatusState } = require("azure-devops-node-api/interfaces/GitInterfaces");

const { app } = require("@azure/functions");

/*
 * This function is configured with V4 of the Azure Functions runtime.
 * See https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-node?tabs=javascript%2Cwindows%2Cazure-cli&pivots=nodejs-model-v4#environment-variables for more information
 */
app.http("chromatic-pr-check", {
  methods: ["POST"],
  authLevel: "anonymous",
  handler: async (request, context) => {
    try {
      const requestBody = await request.json();
      if (!requestBody || Object.keys(requestBody).length === 0) {
        return {
          status: 500,
          jsonBody: {
            message: "Invalid request body",
          },
        };
      }

      context.log("Starting Chromatic Webhook Handler Execution");
      context.log("Azure Function Input:\n", requestBody);

      const { branch, status, webUrl } = requestBody.build;

      context.log("Attempting to get API");
      const authHandler = azureDevOps.getPersonalAccessTokenHandler(
        process.env["CHROMATIC_AZURE_TOKEN"],
      );
      const connection = new azureDevOps.WebApi(
        process.env["ORG_URL"],
        authHandler,
      );
      const AzDevGit = await connection.getGitApi();
      context.log("API Retrieved");

      const repositoryId = process.env["REPOSITORY_ID"];

      const pullRequests = await AzDevGit.getPullRequests(repositoryId, {
        sourceRefName: `refs/heads/${branch}`,
      });

      // Get the first Pull Request in the list
      const pullRequest = pullRequests[0];

      if (!pullRequest) {
        // If there are no open pull requests in the designated branch, no action is required, and we can return a Status OK
        context.log("No PR found");
        return {
          jsonBody: {
            message: `No PR found open for branch ${branch}`,
          },
        };
      }

      const pullRequestId = pullRequest.pullRequestId;

      // Defines a map from Chromatic Webhook Status to the Azure DevOps API
      const pullRequestStatusMap = {
        DENIED: {
          state: GitStatusState.Failed,
          description: "Chromatic Visual Tests Denied",
        },
        PENDING: {
          state: GitStatusState.Pending,
          description: "Chromatic Visual Tests Pending Review",
        },
        ACCEPTED: {
          state: GitStatusState.Succeeded,
          description: "Chromatic Visual Tests Changes Approved",
        },
        PASSED: {
          state: GitStatusState.Succeeded,
          description: "Chromatic Visual Tests Passed",
        },
        FAILED: {
          state: GitStatusState.Failed,
          description: "Chromatic Visual Tests Failed",
        },
      };

      const prStatus = pullRequestStatusMap[status];
      context.log("Trying to create PR status with Azure DevOps API");

      const result = await AzDevGit.createPullRequestStatus(
        {
          context: {
            genre: "chromatic",
            name: "visual-testing",
          },
          ...prStatus,
          // Includes the URL from the Chromatic Webhook to allow for easy navigation to the required page
          targetUrl: webUrl,
        },
        repositoryId,
        pullRequestId,
      );

      return {
        jsonBody: result,
      };
    } catch (error) {
      context.error("Error creating PR status with Azure DevOps API", error);
      return {
        status: 500,
        jsonBody: {
          message: "Error creating PR status with Azure DevOps API",
          error: error.message,
        },
      };
    }
  },
});
```

{/* prettier-ignore-end */}

Configure the necessary environment variables in your Azure function. You can set these environment variables in the Azure portal or the `local.settings.json` file if you run the function locally. The environment variables you need to set are:

- `ORG_URL`: The organization URL of your Azure DevOps account
- `REPOSITORY_ID`: he repository's unique identifier
- `CHROMATIC_AZURE_TOKEN`: A personal access [token](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops) for Azure DevOps

```json title="local.settings.json"
{
  "IsEncrypted": false,
  "Values": {
    "FUNCTIONS_WORKER_RUNTIME": "node",
    "ORG_URL": "https://dev.azure.com/your-organization",
    "REPOSITORY_ID": "your-repository-id",
    "CHROMATIC_AZURE_TOKEN": "your-azure-token",
    "AzureWebJobsStorage": "your-azure-storage-connection-string"
  }
}
```

Deploy the function to Azure using your preferred method, either with the [Azure Developer CLI](https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/install-azd) or the Visual Studio Code [extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions).

```shell
azd deploy
```

Sign in to your Chromatic account, navigate to the project's manage page, and enable a new Webhook connection with the deployed Azure function URL (e.g., `https://your-azure-function-url.azurewebsites.net/api/chromatic-pr-check`).

#### Configure UI Review status check

If you enabled [UI Review](/docs/review) in your Chromatic project, you can adjust the Azure function to generate a dedicated pull request status check, allowing you to preview its status. To enable it, you'll need to adjust the function as follows:

{/* prettier-ignore-start */}

```js title="src/functions/chromatic-status-check.js"
const azureDevOps = require("azure-devops-node-api");

const { GitStatusState} = require("azure-devops-node-api/interfaces/GitInterfaces");

const { app } = require("@azure/functions");

/*
 * This function is configured with V4 of the Azure Functions runtime.
 * See https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-node?tabs=javascript%2Cwindows%2Cazure-cli&pivots=nodejs-model-v4#environment-variables for more information
 */
app.http("chromatic-pr-check", {
  methods: ["POST"],
  authLevel: "anonymous",
  handler: async (request, context) => {
    try {
      const requestBody = await request.json();
      if (!requestBody || Object.keys(requestBody).length === 0) {
        return {
          status: 500,
          jsonBody: {
            message: "Invalid request body",
          },
        };
      }

      context.log("Starting Chromatic Webhook Handler Execution");
      context.log("Azure Function Input:\n", requestBody);

      // Initializes an empty object to store the data from the Chromatic Webhook based on the event type
      let chromaticData = {};

      if (requestBody.event === "build") {
        chromaticData = {
          ...chromaticData,
          type: requestBody.event,
          branch: requestBody.build.branch,
          status: requestBody.build.status,
          url: requestBody.build.webUrl,
        };
      } else {
        chromaticData = {
          ...chromaticData,
          type: requestBody.event,
          branch: requestBody.review.headRefName,
          status: requestBody.review.status,
          url: requestBody.review.webUrl,
        };
      }

      context.log("Attempting to get API");
      const authHandler = azureDevOps.getPersonalAccessTokenHandler(
        process.env["CHROMATIC_AZURE_TOKEN"],
      );
      const connection = new azureDevOps.WebApi(
        process.env["ORG_URL"],
        authHandler,
      );
      const AzDevGit = await connection.getGitApi();
      context.log("API Retrieved");

      const repositoryId = process.env["REPOSITORY_ID"];

      const pullRequests = await AzDevGit.getPullRequests(repositoryId, {
        sourceRefName: `refs/heads/${chromaticData.branch}`,
      });

      // Get the first Pull Request in the list
      const pullRequest = pullRequests[0];

      if (!pullRequest) {
        // If there are no open pull requests in the designated branch, no action is required and we can return a Status OK
        context.log("No PR found");
        return {
          jsonBody: {
            message: `No PR found open for branch ${chromaticData.branch}`,
          },
        };
      }

      const pullRequestId = pullRequest.pullRequestId;

      // Defines a map from Chromatic Webhook Status to the Azure DevOps API
      const pullRequestStatusMap = {
        // Build Statuses
        DENIED: {
          state: GitStatusState.Failed,
          description: "Chromatic Visual Tests Denied",
        },
        PENDING: {
          state: GitStatusState.Pending,
          description: "Chromatic Visual Tests Pending Review",
        },
        ACCEPTED: {
          state: GitStatusState.Succeeded,
          description: "Chromatic Visual Tests Changes Approved",
        },
        PASSED: {
          state: GitStatusState.Succeeded,
          description: "Chromatic Visual Tests Passed",
        },
        FAILED: {
          state: GitStatusState.Failed,
          description: "Chromatic Visual Tests Failed",
        },
        // UI Review Statuses
        OPEN: {
          state: GitStatusState.Pending,
          description: "Chromatic UI Review Pending Review",
        },
        MERGED: {
          state: GitStatusState.Succeeded,
          description: "Chromatic UI Review Changes Approved",
        },
        CLOSED: {
          state: GitStatusState.Failed,
          description: "Chromatic UI Review Changes Denied",
        },
      };

      const prStatus = pullRequestStatusMap[chromaticData.status];
      context.log("Trying to create PR status with Azure DevOps API");

      const result = await AzDevGit.createPullRequestStatus(
        {
          context: {
            genre: "chromatic",
            name:
              chromaticData.type === "build" ? "visual-testing" : "ui-review",
          },
          ...prStatus,
          // Includes the URL from the Chromatic Webhook to allow for easy navigation to the required page depending on the event type
          targetUrl: chromaticData.url,
        },
        repositoryId,
        pullRequestId,
      );

      return {
        jsonBody: result,
      };
    } catch (error) {
      context.error("Error creating PR status with Azure DevOps API", error);
      return {
        status: 500,
        jsonBody: {
          message: "Error creating PR status with Azure DevOps API",
          error: error.message,
        },
      };
    }
  },
});
```

{/* prettier-ignore-end */}

